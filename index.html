<!DOCTYPE html>
<html lang="es">
<head>
  <meta charset="UTF-8" />
  <title>Fondo marino · Andrea Lértora</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />

  <meta http-equiv="Cache-Control" content="no-store, no-cache, must-revalidate, max-age=0" />
  <meta http-equiv="Pragma" content="no-cache" />
  <meta http-equiv="Expires" content="0" />

  <style>
    * { margin: 0; padding: 0; box-sizing: border-box; }

    html, body {
      height: 100%;
      overflow: hidden;
      background:
        radial-gradient(circle at 10% 0%, #3f7f82 0%, #0b3a3e 35%, #020e10 80%),
        linear-gradient(to bottom, #083234, #020b0d);
      font-family: system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI", sans-serif;
      color: #e5f3ff;
    }

    .sea-container {
      position: relative;
      width: 100vw;
      height: 100vh;
      opacity: 0;
      transform: translateY(8px);
      transition: opacity .7s ease-out, transform .7s ease-out;
    }
    .sea-container.visible {
      opacity: 1;
      transform: translateY(0);
    }

    /* ALGA BASE */
    .alga {
      position: absolute;
      pointer-events: none;
      object-fit: cover;
      transform-origin: 50% 100%;
      transform: translateZ(0);
    }

    /* Fondo de algas */
    .alga-bg { z-index: 5; }

    /* Algas enfocadas normales (delante del fondo, detrás del pez) */
    .alga-fg {
      z-index: 20;
      filter: saturate(.95);
      animation: corrientePuppet 12s ease-in-out infinite;
    }

    /* Las dos algas elegidas a los extremos → delante del pez */
    .alga-fg-front {
      z-index: 32;
    }

    @keyframes corrientePuppet {
      0%   { transform: translateY(0) rotate(0deg) skewX(0deg); }
      25%  { transform: translateY(-6px) rotate(.4deg) skewX(1.2deg); }
      50%  { transform: translateY(-10px) rotate(.9deg) skewX(2.4deg); }
      75%  { transform: translateY(-5px) rotate(.3deg) skewX(1.0deg); }
      100% { transform: translateY(0) rotate(0deg) skewX(0deg); }
    }

    /* BLOQUE CENTRAL — TÍTULO Y BOTONES */
    .center-block {
      position: absolute;
      left: 8vw;
      top: 12vh;
      z-index: 100;
    }

    .name {
      display: inline-flex;
      gap: 0.25em;
      font-size: clamp(2.4rem, 4vw, 3.3rem);
      text-transform: uppercase;
      letter-spacing: .32em;
      margin-bottom: .2rem;
      color: #f9fafb;
      text-shadow: 0 1px 0 rgba(0,0,0,.7), 0 18px 40px rgba(0,0,0,.9);
    }
    .name span { display: inline-block; }

    .subtitle {
      font-size: .85rem;
      letter-spacing: .24em;
      color: #a5f3fc;
      margin-bottom: 1.3rem;
      text-transform: uppercase;
    }

    .nav {
      display: flex;
      flex-direction: column;
      gap: .35rem;
    }

    .nav-button {
      width: 177px;
      padding: .20rem .75rem;
      border: none;
      border-radius: 3px;
      background-color: rgba(80,200,190,.35);
      mix-blend-mode: multiply;
      color: #e5f3ff;
      font-size: .7rem;
      letter-spacing: .18em;
      text-transform: uppercase;
      display: flex;
      align-items: center;
      cursor: pointer;
      box-shadow:
        0 2px 4px rgba(0,0,0,.35),
        0 0 0 1px rgba(15,23,42,.45);
      transition: background-color .18s, transform .13s,
                  box-shadow .18s, letter-spacing .13s;
    }

    .nav-button:hover {
      background-color: rgba(94,234,212,.42);
      transform: translateX(2px);
      letter-spacing: .20em;
      box-shadow: 0 6px 14px rgba(0,0,0,.55),
                  0 0 0 1px rgba(15,23,42,.65);
    }

    .nav-button:active {
      background-color: rgba(45,164,150,.52);
      transform: translateY(1px) scale(.99);
      box-shadow: 0 1px 3px rgba(0,0,0,.6),
                  0 0 0 1px rgba(15,23,42,.9);
    }

    /* WRAPPER DEL PEZ (CAPA INTERMEDIA) */
    #fish-wrapper{
      position:absolute;
      z-index:30;
      transform-origin:center center;
      pointer-events:none;
      opacity:0;
      transform:translateY(120%);
      transition: opacity 0.7s ease-out, transform 0.9s ease-out;
    }

    /* PARTÍCULAS */
    .particles {
      position: absolute;
      inset: 0;
      z-index: 35;
      pointer-events: none;
    }

    .particle {
      position: absolute;
      mix-blend-mode: multiply;
      opacity: 0.30;
      animation: particleCurrent ease-in-out infinite alternate;
    }

    @keyframes particleCurrent {
      0%   { transform: translate3d(0,0,0); }
      50%  { transform: translate3d(var(--driftX), var(--ampY), 0); }
      100% { transform: translate3d(0,0,0); }
    }

    .overlay {
      position: absolute;
      inset: 0;
      z-index: 40;
      pointer-events: none;
      background:
        radial-gradient(circle at 50% 15%, rgba(255,255,220,.08), transparent),
        linear-gradient(to bottom, rgba(10,35,45,.50), rgba(0,0,0,.75));
      mix-blend-mode: soft-light;
    }

    .grain {
      position: absolute;
      inset: 0;
      z-index: 45;
      opacity: .16;
      mix-blend-mode: soft-light;
      pointer-events: none;
      background-image: url("data:image/svg+xml,%3Csvg viewBox='0 0 160 160' xmlns='http://www.w3.org/2000/svg'%3E%3Cfilter id='n'%3E%3CfeTurbulence type='fractalNoise' baseFrequency='0.8' numOctaves='3'/%3E%3C/filter%3E%3Crect width='100%25' height='100%25' filter='url(%23n)' opacity='0.9'/%3E%3C/svg%3E");
    }

    /* BOTONES 30% MÁS GRANDES EN CELULARES / IPAD */
    @media (max-width: 768px) {
      .center-block {
        left: 6vw;
        top: 10vh;
      }

      .name {
        font-size: clamp(2rem, 6vw, 2.6rem);
        letter-spacing: .26em;
        flex-direction: column;
        gap: .05em;
      }

      .subtitle {
        font-size: .8rem;
        letter-spacing: .20em;
        margin-bottom: 1.1rem;
      }

      .nav-button {
        width: calc(177px * 1.3);
        padding: calc(.20rem * 1.3) calc(.75rem * 1.3);
        font-size: calc(.7rem * 1.3);
      }
    }

    /* ICONO DE SONIDO */
    #speakerIcon {
      position: fixed;
      bottom: 40px;
      right: 40px;
      width: min(6.51vw, 6.51vh);
      height: min(6.51vw, 6.51vh);
      min-width: 39px;
      min-height: 39px;
      max-width: 74px;
      max-height: 74px;
      border-radius: 50%;
      display: flex;
      align-items: center;
      justify-content: center;
      cursor: pointer;
      backdrop-filter: blur(10px);
      box-shadow: 0 0 25px rgba(0,0,0,0.8);
      opacity: 0;
      transform: scale(0.9);
      transition: opacity 0.35s ease-out, transform 0.35s ease-out;
      z-index: 110;
      touch-action: none;
      user-select: none;
      -webkit-user-drag: none;
    }

    #speakerIcon:hover { opacity: .9; }
    #speakerIcon:active { transform: scale(.95); }

    @keyframes attentionBlink {
      0% { opacity: .55; }
      8% { opacity: 1; }
      16% { opacity: .35; }
      24% { opacity: 1; }
      32% { opacity: .35; }
      40% { opacity: 1; }
      100% { opacity: .55; }
    }
    #speakerIcon.muted { animation: attentionBlink 7s ease-in-out infinite; }
    #speakerIcon.active { animation: none; }

    #speakerIcon img {
      width: 70%;
      height: 70%;
      object-fit: contain;
      filter: drop-shadow(0 0 5px rgba(0,0,0,0.8));
      animation: huePulse 5.8s ease-in-out infinite alternate,
                 floatY 7.4s ease-in-out infinite;
      pointer-events: none;
      -webkit-user-drag: none;
    }

    #speakerIcon.active img {
      animation-duration: 4.8s, 6.2s;
    }
    #speakerIcon.muted img {
      animation-duration: 7.5s, 8.5s;
      opacity: 0.9;
    }

    @keyframes huePulse {
      0% { filter: hue-rotate(0deg) saturate(1) drop-shadow(0 0 5px rgba(0,0,0,.7)); }
      50% { filter: hue-rotate(12deg) saturate(1.25) drop-shadow(0 0 7px rgba(0,0,0,.9)); }
      100% { filter: hue-rotate(-10deg) saturate(1.1) drop-shadow(0 0 5px rgba(0,0,0,.7)); }
    }

    @keyframes floatY {
      0% { transform: translateY(0); }
      50% { transform: translateY(-3px); }
      100% { transform: translateY(0); }
    }

    .ring {
      position: absolute;
      inset: -28%;
      pointer-events: none;
      display: flex;
      align-items: center;
      justify-content: center;
    }

    .ring svg { width: 100%; height: 100%; }

    #ringCircle {
      fill: none;
      stroke-width: 3;
      stroke-linecap: round;
      opacity: .9;
      transform-origin: 50% 50%;
      transform: rotate(-90deg);
      stroke: rgba(135,206,250,.7);
    }

    @keyframes ringColorShift {
      0% { stroke: rgba(135,206,250,.20); }
      25% { stroke: rgba(135,206,250,.85); }
      50% { stroke: rgba(173,216,230,.75); }
      75% { stroke: rgba(144,238,144,.65); }
      100% { stroke: rgba(135,206,250,.20); }
    }

    #speakerIcon.muted #ringCircle,
    #speakerIcon.active #ringCircle {
      animation: ringColorShift 12s ease-in-out infinite;
    }

    /* Estado inicial escalonado */
    .center-block .name,
    .center-block .subtitle,
    .center-block .nav-button {
      opacity: 0;
      transform: translateY(-10px);
    }

    /* BOTÓN PANTALLA COMPLETA (solo texto y corchetes) */
    #fs-toggle {
      position: fixed;
      left: 16px;
      bottom: 18px;
      z-index: 120;
      font-size: 0.72rem;
      letter-spacing: 0.18em;
      text-transform: uppercase;
      color: #e5f3ff;
      display: inline-flex;
      align-items: center;
      gap: 0.45rem;
      cursor: pointer;
      user-select: none;
      transform-origin: left bottom;
      animation: fsGlow 7.5s ease-in-out infinite;
      text-shadow: 0 0 6px rgba(15,23,42,0.9);
      background: none;
      border: none;
      box-shadow: none;
      padding: 0;
    }

    #fs-toggle:hover {
      color: #e0faff;
      transform: translateY(-1px) scale(1.02);
      text-shadow:
        0 0 6px rgba(15,23,42,0.9),
        0 0 16px rgba(56,189,248,0.55);
    }

    #fs-toggle:active {
      transform: translateY(1px) scale(0.99);
      text-shadow: 0 0 4px rgba(15,23,42,0.95);
    }

    #fs-toggle span.label {
      opacity: 0.92;
    }

    #fs-toggle span.brackets {
      font-family: "Menlo", "SFMono-Regular", ui-monospace, monospace;
      font-size: 0.8rem;
      opacity: 0.92;
      display: inline-flex;
      align-items: center;
      justify-content: center;
      animation: bracketsWave 5.8s ease-in-out infinite;
    }

    #fs-toggle.fs-active {
      color: #a5f3fc;
    }

    @keyframes fsGlow {
      0%   { opacity: 0.82; transform: scale(1); }
      30%  { opacity: 0.96; transform: scale(1.02); }
      60%  { opacity: 0.88; transform: scale(1); }
      100% { opacity: 0.82; transform: scale(1); }
    }

    @keyframes bracketsWave {
      0%   { transform: translateX(0) scale(1);   text-shadow: 0 0 0 rgba(56,189,248,0.0); }
      40%  { transform: translateX(1px) scale(1.03); text-shadow: 0 0 10px rgba(56,189,248,0.6); }
      80%  { transform: translateX(0) scale(1);   text-shadow: 0 0 0 rgba(56,189,248,0.0); }
      100% { transform: translateX(0) scale(1);   }
    }

    @media (max-width: 768px) {
      #fs-toggle {
        font-size: 0.78rem;
        left: 12px;
        bottom: 12px;
      }
    }
  </style>
</head>

<body>
  <div class="sea-container" id="sea-container">

    <div class="center-block">
      <div class="name">
        <span class="first">Andrea</span>
        <span class="last">Lértora</span>
      </div>
      <div class="subtitle">artista plástica</div>

      <nav class="nav">
        <button class="nav-button">Bio</button>
        <button class="nav-button">Porta</button>
        <button class="nav-button">Cont</button>
        <button class="nav-button">Fun</button>
      </nav>
    </div>

    <!-- Pez animado, sin su propio fondo -->
    <div id="fish-wrapper"></div>

    <div class="particles" id="particles-layer"></div>
    <div class="overlay"></div>
    <div class="grain"></div>
  </div>

  <!-- Icono de sonido -->
  <div id="speakerIcon" class="muted">
    <div class="ring">
      <svg viewBox="0 0 60 60">
        <circle id="ringCircle" cx="30" cy="30" r="24"></circle>
      </svg>
    </div>
    <img src="sonido/icono.png" alt="Audio marino" draggable="false">
  </div>

  <!-- Botón pantalla completa (solo texto) -->
  <div id="fs-toggle">
    <span class="label">pantalla completa</span>
    <span class="brackets">[  ]</span>
  </div>

  <!-- SCRIPT FONDO MARINO -->
  <script>
  (function () {
    "use strict";

    const algaeSources = [
      "algas/algas 1.png","algas/algas 2.png","algas/algas 3.png",
      "algas/algas 4.png","algas/algas 5.png"
    ];

    const container = document.getElementById("sea-container");
    const particlesContainer = document.getElementById("particles-layer");

    let bgImages = [];
    let fgImages = [];
    let bgReady = false;
    let fgReady = false;
    let revealed = false;

    const random = (a, b) => a + Math.random() * (b - a);

    const getVH = () =>
      window.innerHeight || document.documentElement.clientHeight || screen.height;
    const getVW = () =>
      window.innerWidth || document.documentElement.clientWidth || screen.width;

    const isPortrait = () => getVH() > getVW();

    function applyRandomMask(img) {
      const cut = random(82, 94);
      const gradient =
        `linear-gradient(to bottom,
          rgba(0,0,0,1) 0%,
          rgba(0,0,0,1) ${cut}%,
          rgba(0,0,0,0) 100%)`;

      img.style.webkitMaskImage = gradient;
      img.style.maskImage = gradient;
      img.style.webkitMaskSize = "100% 100%";
      img.style.maskSize = "100% 100%";
      img.style.webkitMaskRepeat = "no-repeat";
      img.style.maskRepeat = "no-repeat";
    }

    // Escalonado del título/subtítulo/botones
    function startTextStagger() {
      const nameEl = container.querySelector(".name");
      const subtitleEl = container.querySelector(".subtitle");
      const buttons = container.querySelectorAll(".nav-button");

      if (!nameEl || !subtitleEl || !buttons.length) return;

      const elements = [nameEl, subtitleEl, ...buttons];

      elements.forEach(el => {
        el.style.opacity = "0";
        el.style.transform = "translateY(-10px)";
      });

      const baseDelay = 150;
      const step = 120;

      elements.forEach((el, index) => {
        setTimeout(() => {
          el.style.transition = "opacity 0.55s ease-out, transform 0.55s ease-out";
          el.style.opacity = "1";
          el.style.transform = "translateY(0)";
        }, baseDelay + index * step);
      });

      const lastIndex = elements.length - 1;
      const lastStart = baseDelay + lastIndex * step;
      const lastDuration = 550;
      const buttonsDoneAt = lastStart + lastDuration;

      // 1 s después de los botones → entra el pez
      setTimeout(() => {
        if (window.startFishIntro) {
          window.startFishIntro();
        }
      }, buttonsDoneAt + 1000);
    }

    function tryReveal() {
      if (bgReady && fgReady && !revealed) {
        revealed = true;
        container.classList.add("visible");
        startTextStagger();
      }
    }

    // Evita clustering de PNG
    function pickAlgaSrcNoCluster(prev1, prev2) {
      let candidates = algaeSources.filter(s => s !== prev1 && s !== prev2);
      if (!candidates.length) candidates = algaeSources.filter(s => s !== prev1);
      if (!candidates.length) candidates = algaeSources.slice();
      return candidates[Math.floor(Math.random() * candidates.length)];
    }

    function createSea() {
      container.querySelectorAll("img.alga").forEach(e => e.remove());
      bgImages = [];
      fgImages = [];
      bgReady = false;
      fgReady = false;
      revealed = false;
      container.classList.remove("visible");
      loadBG();
      loadFG();
    }

    /* FONDO (ALGAS DESENFOCADAS) */
    function loadBG() {
      const portrait = isPortrait();

      const baseCount = portrait
        ? Math.floor(random(3, 5))
        : Math.floor(random(7, 11));

      const count = baseCount;

      let done = 0;
      bgImages = [];

      let prev1 = null;
      let prev2 = null;

      for (let i = 0; i < count; i++) {
        const img = document.createElement("img");
        img.className = "alga alga-bg";

        const src = pickAlgaSrcNoCluster(prev1, prev2);
        img.src = src;
        prev2 = prev1;
        prev1 = src;

        applyRandomMask(img);

        img.style.opacity = random(.22, .40);
        img.style.filter = `blur(${random(1.2, 3.2)}px) saturate(.8)`;
        if (Math.random() < .5) img.style.transform = "scaleX(-1)";

        img.onload = () => {
          done++;
          if (done === count) layoutBG();
        };

        bgImages.push(img);
        container.insertBefore(img, container.firstChild);
      }
    }

    function layoutBG() {
      if (!bgImages.length) return;

      const vh = getVH();
      const vw = getVW();

      const totalHeight = vh;
      const topOffset = 0;

      const marginLeft = vw * 0.03;
      const marginRight = vw * 0.03;

      const n = bgImages.length;
      const segments = n + 1;
      const segmentWidth = vw / segments;

      bgImages.forEach((img, index) => {
        const ratio = img.naturalWidth / img.naturalHeight || 0.4;
        let width = totalHeight * ratio;
        const maxWidth = vw * 0.35;
        if (width > maxWidth) width = maxWidth;

        let center = (index + 1) * segmentWidth;
        let left = center - width / 2;

        if (left < marginLeft) left = marginLeft;
        if (left + width > vw - marginRight) left = vw - marginRight - width;

        img.style.height = totalHeight + "px";
        img.style.width = width + "px";
        img.style.top = topOffset + "px";
        img.style.left = left + "px";
      });

      bgReady = true;
      tryReveal();
    }

    /* FRENTE (ALGAS DELANTERAS) */
    function loadFG() {
      const portrait = isPortrait();

      const baseCount = portrait
        ? Math.floor(random(3, 6))
        : Math.floor(random(7, 12));

      const count = baseCount;

      let done = 0;
      fgImages = [];

      let prev1 = null;
      let prev2 = null;

      for (let i = 0; i < count; i++) {
        const img = document.createElement("img");
        img.className = "alga alga-fg";

        const src = pickAlgaSrcNoCluster(prev1, prev2);
        img.src = src;
        prev2 = prev1;
        prev1 = src;

        applyRandomMask(img);

        img.style.opacity = random(.50, .78);
        if (Math.random() < .5) img.style.transform = "scaleX(-1)";

        img.onload = () => {
          done++;
          if (done === count) layoutFG();
        };

        fgImages.push(img);
        container.insertBefore(img, container.querySelector(".overlay"));
      }
    }

    // Marca las dos algas enfocadas más extremas
    function markFrontForegroundAlgae() {
      if (!fgImages.length) return;
      fgImages.forEach(img => img.classList.remove("alga-fg-front"));
      if (fgImages.length < 2) return;

      const sorted = [...fgImages].sort((a, b) => a.offsetLeft - b.offsetLeft);
      const leftMost = sorted[0];
      const rightMost = sorted[sorted.length - 1];

      leftMost.classList.add("alga-fg-front");
      rightMost.classList.add("alga-fg-front");
    }

    function layoutFG() {
      if (!fgImages.length) return;

      const vh = getVH();
      const vw = getVW();

      const totalHeight = vh;
      const topOffset = 0;
      const segments = fgImages.length - 1 || 1;
      const segmentWidth = vw / segments;

      fgImages.forEach((img, i) => {
        const ratio = img.naturalWidth / img.naturalHeight || 0.4;
        const width = totalHeight * ratio * 1.05;

        const center = i * segmentWidth + random(-segmentWidth * 0.15, segmentWidth * 0.15);
        const left = center - width / 2;

        img.style.height = totalHeight + "px";
        img.style.width = width + "px";
        img.style.top = topOffset + "px";
        img.style.left = left + "px";
      });

      markFrontForegroundAlgae();

      fgReady = true;
      tryReveal();
    }

    /* PARTÍCULAS */
    function createParticles() {
      particlesContainer.innerHTML = "";

      const palette = [
        "rgba(200,230,240,0.40)",
        "rgba(180,210,220,0.38)",
        "rgba(160,200,210,0.34)",
        "rgba(140,180,190,0.32)"
      ];

      const totalParticles = 150;

      for (let i = 0; i < totalParticles; i++) {
        const p = document.createElement("div");
        p.className = "particle";

        const w = random(2, 10);
        const h = random(2, 10);
        p.style.width = w + "px";
        p.style.height = h + "px";

        const r1 = random(40, 90);
        const r2 = random(40, 90);
        const r3 = random(40, 90);
        const r4 = random(40, 90);
        p.style.borderRadius = `${r1}% ${r2}% ${r3}% ${r4}%`;

        p.style.background = palette[Math.floor(Math.random() * palette.length)];

        if (Math.random() > 0.10) {
          p.style.filter = `blur(${random(0.5, 3)}px)`;
        }

        p.style.left = random(0, 100) + "vw";
        p.style.top = random(0, 100) + "vh";

        p.style.setProperty("--driftX", random(3, 10) + "vw");
        p.style.setProperty("--ampY", random(-8, 8) + "px");

        p.style.animationDuration = random(14, 30) + "s";
        p.style.animationDelay = random(-25, 0) + "s";

        particlesContainer.appendChild(p);
      }
    }

    function relayoutScene() {
      layoutBG();
      layoutFG();
      createParticles();
    }

    document.addEventListener("DOMContentLoaded", () => {
      createSea();
      createParticles();
    });

    window.addEventListener("resize", relayoutScene);

    window.addEventListener("orientationchange", () => {
      setTimeout(relayoutScene, 300);
    });
  })();
  </script>

  <!-- SCRIPT DEL SONIDO -->
  <script>
  (function () {
    "use strict";

    let audioCtx = null;
    let masterGain = null;
    let filter = null;

    let running = false;
    let userVolume = 0.45;
    const MIN_VOL = 0.12;
    const MAX_VOL = 0.7;

    let padTimeoutId = null;
    let leadOsc = null;
    let leadGain = null;
    let leadTimeoutId = null;
    let noiseSource = null;
    let noiseGain = null;
    let noiseFilter = null;
    let noiseTimeoutId = null;

    const bassRoot = 55;
    const pentatonicSteps = [0, 2, 4, 7, 9];

    const speakerIcon = document.getElementById("speakerIcon");
    const ringCircle = document.getElementById("ringCircle");
    let ringLength = 0;

    function randomPentatonicFreq() {
      const semis = 24 + pentatonicSteps[Math.floor(Math.random() * pentatonicSteps.length)];
      return bassRoot * Math.pow(2, semis / 12);
    }

    function smoothFadeTo(targetValue, durationSeconds) {
      if (!audioCtx || !masterGain) return;
      const now = audioCtx.currentTime;
      const current = masterGain.gain.value;

      masterGain.gain.cancelScheduledValues(now);
      masterGain.gain.setValueAtTime(current, now);
      masterGain.gain.linearRampToValueAtTime(targetValue, now + durationSeconds);
    }

    function createContext() {
      audioCtx = new (window.AudioContext || window.webkitAudioContext)();

      masterGain = audioCtx.createGain();
      masterGain.gain.value = 0;

      filter = audioCtx.createBiquadFilter();
      filter.type = "lowpass";
      filter.frequency.value = 1000;
      filter.Q.value = 0.7;

      filter.connect(masterGain);
      masterGain.connect(audioCtx.destination);

      createBassLayer();
      startPadLoop();
      createLeadVoice();
      createNoiseLayer();

      smoothFadeTo(userVolume, 2.5);
    }

    function createBassLayer() {
      [bassRoot, bassRoot * 1.2].forEach((f, i) => {
        const osc = audioCtx.createOscillator();
        const g = audioCtx.createGain();

        osc.type = "sine";
        osc.frequency.value = f;

        g.gain.value = 0;
        osc.connect(g);
        g.connect(filter);

        g.gain.linearRampToValueAtTime(
          0.12 + i * 0.03,
          audioCtx.currentTime + 5 + i * 1.5
        );
        osc.start();
      });
    }

    function spawnPadNote() {
      if (!audioCtx) return;
      const bases = [196, 220, 246.94, 261.63, 293.66];
      const base = bases[Math.floor(Math.random() * bases.length)];

      const osc = audioCtx.createOscillator();
      const g = audioCtx.createGain();
      osc.type = Math.random() < 0.5 ? "sine" : "triangle";
      osc.frequency.value = base;

      g.gain.value = 0;
      osc.connect(g);
      g.connect(filter);

      const now = audioCtx.currentTime;
      const total = 1.4 + Math.random() * 1.4;
      const fin = 0.3 + Math.random() * 0.5;
      const fout = 0.4 + Math.random() * 0.8;
      const sus = Math.max(0.2, total - fin - fout);
      const peak = 0.06 + Math.random() * 0.05;

      g.gain.linearRampToValueAtTime(peak, now + fin);
      g.gain.linearRampToValueAtTime(peak, now + fin + sus);
      g.gain.linearRampToValueAtTime(0, now + total);

      osc.start();
      osc.stop(now + total + 0.2);
    }

    function scheduleNextPad() {
      if (!running || !audioCtx) return;
      spawnPadNote();
      padTimeoutId = setTimeout(scheduleNextPad, 500 + Math.random() * 2000);
    }

    function startPadLoop() {
      setTimeout(() => {
        if (running) scheduleNextPad();
      }, 800);
    }

    function createLeadVoice() {
      leadOsc = audioCtx.createOscillator();
      leadGain = audioCtx.createGain();
      leadOsc.type = "triangle";
      leadOsc.frequency.value = randomPentatonicFreq();
      leadGain.gain.value = 0;

      leadOsc.connect(leadGain);
      leadGain.connect(filter);

      leadGain.gain.linearRampToValueAtTime(0.03, audioCtx.currentTime + 3);
      leadOsc.start();
      scheduleNextLeadStep();
    }

    function scheduleNextLeadStep() {
      if (!running || !audioCtx) return;
      const now = audioCtx.currentTime;
      leadOsc.frequency.setValueAtTime(randomPentatonicFreq(), now);

      const dur = 0.8 + Math.random() * 2;
      const newGain = 0.02 + Math.random() * 0.02;
      leadGain.gain.linearRampToValueAtTime(newGain, now + dur * 0.5);

      leadTimeoutId = setTimeout(scheduleNextLeadStep, dur * 1000);
    }

    function createNoiseLayer() {
      const buf = audioCtx.createBuffer(1, 2 * audioCtx.sampleRate, audioCtx.sampleRate);
      const data = buf.getChannelData(0);
      for (let i = 0; i < data.length; i++) {
        data[i] = (Math.random() * 2 - 1) * 0.5;
      }

      noiseSource = audioCtx.createBufferSource();
      noiseSource.buffer = buf;
      noiseSource.loop = true;

      noiseGain = audioCtx.createGain();
      noiseGain.gain.value = 0;

      noiseFilter = audioCtx.createBiquadFilter();
      noiseFilter.type = "bandpass";
      noiseFilter.frequency.value = 1500;

      noiseSource.connect(noiseFilter);
      noiseFilter.connect(noiseGain);
      noiseGain.connect(filter);

      noiseSource.start();

      noiseGain.gain.linearRampToValueAtTime(0.024, audioCtx.currentTime + 3);
      scheduleNextNoiseMod();
    }

    function scheduleNextNoiseMod() {
      if (!running || !audioCtx) return;
      const now = audioCtx.currentTime;
      const t = 2 + Math.random() * 3;
      const base = 0.02 + Math.random() * 0.05;
      const g = base * 0.6;

      noiseGain.gain.linearRampToValueAtTime(g, now + t);
      noiseTimeoutId = setTimeout(scheduleNextNoiseMod, t * 1000);
    }

    function startSea() {
      if (running) return;
      running = true;
      speakerIcon.classList.remove("muted");
      speakerIcon.classList.add("active");

      if (!audioCtx || audioCtx.state === "closed") {
        createContext();
      } else if (audioCtx.state === "suspended") {
        audioCtx.resume();
        smoothFadeTo(userVolume, 2.0);
      } else {
        smoothFadeTo(userVolume, 2.0);
      }
    }

    function stopSea() {
      if (!running || !audioCtx) return;
      running = false;

      speakerIcon.classList.add("muted");
      speakerIcon.classList.remove("active");

      smoothFadeTo(0, 2.8);

      if (padTimeoutId) { clearTimeout(padTimeoutId); padTimeoutId = null; }
      if (leadTimeoutId) { clearTimeout(leadTimeoutId); leadTimeoutId = null; }
      if (noiseTimeoutId) { clearTimeout(noiseTimeoutId); noiseTimeoutId = null; }

      setTimeout(() => {
        if (audioCtx) {
          audioCtx.close();
          audioCtx = null;
        }
      }, 3200);
    }

    function initRing() {
      const r = parseFloat(ringCircle.getAttribute("r"));
      ringLength = 2 * Math.PI * r;
      ringCircle.style.strokeDasharray = ringLength;
      updateVolumeVisual();
    }

    function updateVolumeVisual() {
      let ratio = (userVolume - MIN_VOL) / (MAX_VOL - MIN_VOL);
      ratio = Math.max(0, Math.min(1, ratio));
      ringCircle.style.strokeDashoffset = ringLength * (1 - ratio);
    }

    function applyVolumeChange() {
      if (!audioCtx || !masterGain) return;
      smoothFadeTo(userVolume, 0.2);
      updateVolumeVisual();
    }

    let dragging = false;
    let lastY = 0;
    let moved = false;
    let activePointerId = null;

    speakerIcon.addEventListener("dragstart", e => e.preventDefault());

    speakerIcon.addEventListener("pointerdown", e => {
      if (e.pointerType === "mouse" && e.button !== 0) return;
      e.preventDefault();
      dragging = true;
      moved = false;
      lastY = e.clientY;
      activePointerId = e.pointerId;
      speakerIcon.setPointerCapture(e.pointerId);
    });

    speakerIcon.addEventListener("pointermove", e => {
      if (!dragging || e.pointerId !== activePointerId) return;

      if (e.pointerType === "mouse" && !(e.buttons & 1)) {
        dragging = false;
        speakerIcon.releasePointerCapture(activePointerId);
        activePointerId = null;
        return;
      }

      const dy = e.clientY - lastY;
      if (Math.abs(dy) > 2) moved = true;
      lastY = e.clientY;

      userVolume = Math.max(
        MIN_VOL,
        Math.min(MAX_VOL, userVolume - dy * 0.002)
      );
      applyVolumeChange();
    });

    function endPointer(e) {
      if (!dragging || !activePointerId || e.pointerId !== activePointerId) return;
      e.preventDefault();
      dragging = false;
      speakerIcon.releasePointerCapture(e.pointerId);
      activePointerId = null;

      if (!moved) {
        if (running) stopSea();
        else startSea();
      }
    }

    speakerIcon.addEventListener("pointerup", endPointer);
    speakerIcon.addEventListener("pointercancel", endPointer);

    window.addEventListener("load", () => {
      initRing();
    });

    // Mostrar icono de sonido cuando toque
    window.showSpeakerIcon = function showSpeakerIcon() {
      speakerIcon.style.opacity = "0.85";
      speakerIcon.style.transform = "scale(1)";
    };
  })();
  </script>

  <!-- SCRIPT PEZ ANIMADO -->
  <script>
  const pez    = new Image();
  const brillo = new Image();
  const aleta  = new Image();

  pez.src    = "pez/peces/pezprincipal.png";
  brillo.src = "pez/peces/pezbrillo.png";
  aleta.src  = "pez/peces/pezaleta.png";

  let loaded = 0;
  [pez, brillo, aleta].forEach(img => {
    img.onload = () => {
      loaded++;
      if (loaded === 3) {
        setupFish();
        initState();
        start();
        window.addEventListener("resize", setupFish);
      }
    };
  });

  let canvas, ctx;
  let fishWidth, fishHeight, scaleFactor;

  function setupFish(){
    const wrapper = document.getElementById("fish-wrapper");

    if (!canvas) {
      canvas = document.createElement("canvas");
      ctx = canvas.getContext("2d");
      wrapper.appendChild(canvas);
    }

    let scale = 0.25;
    const ua = navigator.userAgent || navigator.vendor || "";
    const isiOS = /iPhone|iPad|iPod/i.test(ua);
    if (isiOS) {
      scale = 0.5;
    }

    fishWidth  = window.innerWidth * scale;
    fishHeight = fishWidth * (pez.height / pez.width);

    canvas.width  = fishWidth;
    canvas.height = fishHeight;

    scaleFactor = fishWidth / pez.width;

    drawFish();
    updateFishWrapper();
  }

  let time = 0;
  let last = null;

  let xPos = 0.3;
  let horiz = "drift";
  let leftTarget  = 0.2;
  let rightTarget = 0.9;
  let swimT   = 0;
  let swimDur = 10;
  let swimStart = 0.9;
  let swimEnd   = 0.2;

  let yPos   = 0.5;
  let yState = "rest";
  let yTimer = 0;
  let yDur   = 5;
  let yStart = 0.5;
  let yEnd   = 0.5;

  const TAIL_SLOW = 0.16;
  const TAIL_FAST = 0.32;
  let tailFreq       = TAIL_SLOW;
  let tailFreqTarget = TAIL_SLOW;
  let tailPhase = 0;
  let tailScale = 1;

  let glowMode       = "low";
  let glowVal        = 0.4;
  let glowStart      = 0;
  let glowDur        = 10;
  let glowOsc        = 0;
  let glowTrans      = false;
  let glowTransStart = 0;
  let glowTransDur   = 0;
  let glowFrom       = 0;
  let glowTo         = 0;

  const LOW_MIN  = 0.31, LOW_MAX  = 0.53;
  const HIGH_MIN = 0.75, HIGH_MAX = 1.0;

  let finSpeed       = 1.0;
  let finSpeedTarget = 1.0;
  const FIN_LERP     = 1.2;

  let fishCanMove = false;
  let fishIntroStarted = false;

  function rand(a,b){ return a + Math.random()*(b-a); }
  function clamp01(v){ return Math.max(0.2, Math.min(0.8, v)); }
  function ease(t){ return t<0.5 ? 2*t*t : 1 - Math.pow(-2*t+2,2)/2; }

  function initState(){
    glowDur   = rand(7,17);
    glowStart = time;
    glowMode  = "low";
    glowVal   = 0.4;
    glowOsc   = 0;

    xPos        = 0.3;
    horiz       = "drift";
    leftTarget  = rand(0.10, 0.30);
    rightTarget = rand(0.83, 0.93);
    swimStart   = rightTarget;
    swimEnd     = leftTarget;
    swimDur     = rand(8,14);
    swimT       = 0;

    yPos       = 0.5;
    yStart     = 0.5;
    yEnd       = 0.5;
    yState     = "rest";
    yTimer     = 0;
    yDur       = rand(5,7);

    tailFreq       = TAIL_SLOW;
    tailFreqTarget = TAIL_SLOW;
    tailScale      = 1;

    finSpeed       = 1.0;
    finSpeedTarget = 1.0;

    fishCanMove    = false;
  }

  function start(){ requestAnimationFrame(loop); }

  function loop(ts){
    if(!last) last = ts;
    const dt = (ts - last) / 1000;
    last = ts;
    time += dt;

    if (fishCanMove) {
      updateHorizontal(dt);
      updateVertical(dt);
    }
    updateTail(dt);
    updateGlow(dt);
    updateFin(dt);

    drawFish();
    updateFishWrapper();

    requestAnimationFrame(loop);
  }

  const DRIFT_SPEED = 0.02;

  function updateHorizontal(dt){
    if (horiz === "drift") {
      xPos += DRIFT_SPEED * dt;

      if (xPos >= rightTarget) {
        xPos = rightTarget;
        horiz = "swim";
        swimStart = xPos;
        swimEnd   = leftTarget = rand(0.10, 0.30);
        swimDur   = rand(8,14);
        swimT     = 0;

        tailFreqTarget = TAIL_FAST;
      }

    } else {
      swimT += dt / swimDur;
      const p = Math.min(1, swimT);
      const e = ease(p);
      xPos = swimStart + (swimEnd - swimStart) * e;

      if (p >= 1) {
        horiz = "drift";
        rightTarget = rand(0.83, 0.93);
        tailFreqTarget = TAIL_SLOW;
      }
    }

    if (xPos < 0) xPos = 0;
    if (xPos > 1) xPos = 1;
  }

  function updateVertical(dt){
    if (yState === "rest") {
      yTimer += dt;
      if (yTimer >= yDur) {
        yState = "move";
        yTimer = 0;

        yDur = rand(2.0, 2.8);

        yStart = yPos;
        let ny;
        do { ny = clamp01(rand(0.2,0.8)); }
        while (Math.abs(ny - yPos) < 0.10);
        yEnd = ny;
      }

    } else {
      yTimer += dt;
      let t = Math.min(1, yTimer / yDur);
      const e = ease(t);
      yPos = yStart + (yEnd - yStart) * e;

      if (t >= 1) {
        yState = "rest";
        yTimer = 0;
        yDur   = rand(5,7);
        yPos   = yEnd;
      }
    }
  }

  function updateTail(dt){
    const diff = tailFreqTarget - tailFreq;
    const step = 1.2 * dt;
    if(Math.abs(diff) <= step) tailFreq = tailFreqTarget;
    else tailFreq += Math.sign(diff)*step;

    tailPhase += dt * tailFreq;
    const wave = (Math.sin(tailPhase * 2*Math.PI) + 1) / 2;
    tailScale = 0.6 + wave * 0.4;
  }

  function updateGlow(dt){
    if (glowTrans) {
      let t = (time - glowTransStart) / glowTransDur;
      if (t>1) t=1;
      const e = ease(t);
      glowVal = glowFrom + (glowTo - glowFrom)*e;

      if (t>=1) {
        glowTrans = false;
        glowStart = time;
        glowOsc   = 0;
      }
      return;
    }

    glowOsc += dt / glowDur;
    if (glowOsc>1) glowOsc -= 1;
    const w = (Math.sin(glowOsc*2*Math.PI)+1)/2;

    if (glowMode==="low") {
      glowVal = LOW_MIN + w*(LOW_MAX-LOW_MIN);

      if (time - glowStart >= glowDur) {
        glowTrans      = true;
        glowTransStart = time;
        glowTransDur   = rand(0.5,1);
        glowFrom       = glowVal;
        glowTo         = HIGH_MIN;
        glowMode       = "high";
        glowDur        = rand(3,5);
      }

    } else {
      glowVal = HIGH_MIN + w*(HIGH_MAX-HIGH_MIN);

      if (time - glowStart >= glowDur) {
        glowTrans      = true;
        glowTransStart = time;
        glowTransDur   = rand(0.5,1);
        glowFrom       = glowVal;
        glowTo         = (LOW_MIN+LOW_MAX)/2;
        glowMode       = "low";
        glowDur        = rand(7,17);
      }
    }
  }

  function updateFin(dt){
    const noise =
        Math.sin(time*0.35)*0.10 +
        Math.sin(time*0.88)*0.05;

    const isMoving = (yState === "move");

    finSpeedTarget = 1.0 * (isMoving ? 1.15 : 1.0) + noise;
    finSpeedTarget = Math.max(0.7, Math.min(1.3, finSpeedTarget));

    const diff = finSpeedTarget - finSpeed;
    const step = FIN_LERP * dt;
    if(Math.abs(diff)<=step) finSpeed=finSpeedTarget;
    else finSpeed += Math.sign(diff)*step;
  }

  function updateFishWrapper(){
    const fw = document.getElementById("fish-wrapper");
    const margin=window.innerWidth*0.03;

    let minX=margin;
    let maxX=window.innerWidth-fishWidth-margin;
    if(maxX<minX) minX=maxX=(window.innerWidth-fishWidth)/2;

    const x=minX+(maxX-minX)*xPos;
    const usableH=window.innerHeight-fishHeight;
    const y=usableH*yPos;

    fw.style.left=x+"px";
    fw.style.top=y+"px";
  }

  function drawFish(){
    if(!ctx) return;
    ctx.clearRect(0,0,fishWidth,fishHeight);

    const srcW=pez.width, srcH=pez.height;

    const split=0.6;
    const srcMid=srcW*split;
    const srcTail=srcW-srcMid;

    const dstMid=fishWidth*split;
    const dstTail=fishWidth-dstMid;

    const seg=14;
    const base=dstTail/seg;

    ctx.drawImage(pez,0,0,srcMid,srcH,0,0,dstMid,fishHeight);

    let x=dstMid;
    for(let i=0;i<seg;i++){
      const u0=i/seg, u1=(i+1)/seg;
      const s0=srcMid+srcTail*u0;
      const sw=srcTail*(u1-u0);
      const fade=Math.pow(u0,1.8);
      const sc=1+(tailScale-1)*fade;
      const dw=base*sc;

      ctx.drawImage(pez,s0,0,sw,srcH,x,0,dw,fishHeight);
      x+=dw;
    }

    ctx.save();
    ctx.globalAlpha=glowVal;

    ctx.drawImage(brillo,0,0,srcMid,srcH,0,0,dstMid,fishHeight);

    x=dstMid;
    for(let i=0;i<seg;i++){
      const u0=i/seg,u1=(i+1)/seg;
      const s0=srcMid+srcTail*u0;
      const sw=srcTail*(u1-u0);
      const fade=Math.pow(u0,1.8);
      const sc=1+(tailScale-1)*fade;
      const dw=base*sc;

      ctx.drawImage(brillo,s0,0,sw,srcH,x,0,dw,fishHeight);
      x+=dw;
    }
    ctx.restore();

    ctx.save();

    const aw=aleta.width*scaleFactor;
    const ah=aleta.height*scaleFactor;

    const left=fishWidth*0.26;
    const top =fishHeight*0.57;

    ctx.translate(left, top + ah*0.5);

    const angle=Math.sin(time * finSpeed) * 0.26;
    ctx.rotate(angle);

    ctx.drawImage(aleta,0,-ah*0.5,aw,ah);

    ctx.restore();
  }

  // Intro del pez + logo sonido
  window.startFishIntro = function startFishIntro() {
    if (fishIntroStarted) return;
    fishIntroStarted = true;

    const fw = document.getElementById("fish-wrapper");
    if (!fw) return;

    updateFishWrapper();

    fw.style.opacity = "1";
    fw.style.transform = "translateY(0)";

    setTimeout(() => {
      fishCanMove = true;
    }, 1000);

    setTimeout(() => {
      if (window.showSpeakerIcon) {
        window.showSpeakerIcon();
      }
    }, 2000);
  };
  </script>

  <!-- SCRIPT PANTALLA COMPLETA (BOTÓN INFERIOR IZQUIERDO) -->
  <script>
  (function () {
    "use strict";

    const fsToggle = document.getElementById("fs-toggle");

    function requestFullscreen(elem) {
      if (elem.requestFullscreen) return elem.requestFullscreen();
      if (elem.webkitRequestFullscreen) return elem.webkitRequestFullscreen();
      if (elem.mozRequestFullScreen) return elem.mozRequestFullScreen();
      if (elem.msRequestFullscreen) return elem.msRequestFullscreen();
    }

    function exitFullscreen() {
      if (document.exitFullscreen) return document.exitFullscreen();
      if (document.webkitExitFullscreen) return document.webkitExitFullscreen();
      if (document.mozCancelFullScreen) return document.mozCancelFullScreen();
      if (document.msExitFullscreen) return document.msExitFullscreen();
    }

    function isFullscreen() {
      return (
        document.fullscreenElement ||
        document.webkitFullscreenElement ||
        document.mozFullScreenElement ||
        document.msFullscreenElement
      );
    }

    function updateFsButtonState() {
      if (isFullscreen()) {
        fsToggle.classList.add("fs-active");
      } else {
        fsToggle.classList.remove("fs-active");
      }
    }

    document.addEventListener("fullscreenchange", updateFsButtonState);
    document.addEventListener("webkitfullscreenchange", updateFsButtonState);
    document.addEventListener("mozfullscreenchange", updateFsButtonState);
    document.addEventListener("MSFullscreenChange", updateFsButtonState);

    fsToggle.addEventListener("click", function (e) {
      e.preventDefault();
      e.stopPropagation();

      if (isFullscreen()) {
        exitFullscreen();
      } else {
        requestFullscreen(document.documentElement);
      }
    });
  })();
  </script>
</body>
</html>
